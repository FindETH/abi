import { decode, encode } from './abi';
import { fromHex, toHex } from './utils';

describe('encode', () => {
  it('encodes simple values', () => {
    expect(toHex(encode(['uint256', 'uint256'] as const, [12345n, 12345n]))).toBe(
      '00000000000000000000000000000000000000000000000000000000000030390000000000000000000000000000000000000000000000000000000000003039'
    );
  });

  it('encodes array values', () => {
    expect(toHex(encode(['uint256', 'uint256[]', 'uint256'] as const, [12345n, [67890n, 67890n], 12345n]))).toBe(
      '000000000000000000000000000000000000000000000000000000000000303900000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000003039000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000109320000000000000000000000000000000000000000000000000000000000010932'
    );
    expect(toHex(encode(['string', 'string', 'string'] as const, ['foo', 'bar', 'baz']))).toBe(
      '000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000003666f6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036261720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000362617a0000000000000000000000000000000000000000000000000000000000'
    );
  });

  it('encodes nested values', () => {
    expect(
      toHex(
        encode(['uint256', 'uint256[][]', 'uint256'] as const, [
          12345n,
          [
            [54321n, 12345n],
            [67890n, 98760n]
          ],
          12345n
        ])
      )
    ).toBe(
      '0000000000000000000000000000000000000000000000000000000000003039000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000030390000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000d43100000000000000000000000000000000000000000000000000000000000030390000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000001093200000000000000000000000000000000000000000000000000000000000181c8'
    );
  });

  it('encodes bytes values', () => {
    const bytes = fromHex('123456789abcdef123456789abcdef123456789abcde');
    expect(toHex(encode(['bytes'] as const, [bytes]))).toBe(
      '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000016123456789abcdef123456789abcdef123456789abcde00000000000000000000'
    );
  });

  it('encodes string values', () => {
    const string = 'foo bar baz qux quux corge';
    expect(toHex(encode(['string'] as const, [string]))).toBe(
      '0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a666f6f206261722062617a20717578207175757820636f726765000000000000'
    );
  });
});

describe('decode', () => {
  it('decodes a token transfer', () => {
    const buffer = fromHex(
      '0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000003039'
    );
    expect(decode(['address', 'uint256'] as const, buffer)).toStrictEqual([
      '0x6b175474e89094c44da98b954eedeac495271d0f',
      12345n
    ]);
  });

  it('decodes array values', () => {
    const buffer = fromHex(
      '000000000000000000000000000000000000000000000000000000000000303900000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000003039000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000109320000000000000000000000000000000000000000000000000000000000010932'
    );
    expect(decode(['uint256', 'uint256[]', 'uint256'] as const, buffer)).toStrictEqual([
      12345n,
      [67890n, 67890n],
      12345n
    ]);
    expect(
      decode(
        ['string[]'],
        fromHex(
          '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000003666f6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036261720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000362617a0000000000000000000000000000000000000000000000000000000000'
        )
      )
    ).toStrictEqual([['foo', 'bar', 'baz']]);
  });

  it('decodes bytes values', () => {
    const buffer = fromHex(
      '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000016123456789abcdef123456789abcdef123456789abcde00000000000000000000'
    );
    expect(toHex(decode(['bytes'] as const, buffer)[0])).toBe('123456789abcdef123456789abcdef123456789abcde');
  });
});
